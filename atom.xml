<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Terry&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-09-26T16:12:20.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Terry</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>窥探Vue.js2.0</title>
    <link href="http://yoursite.com/2016/09/26/%E7%AA%BA%E6%8E%A2Vue2/"/>
    <id>http://yoursite.com/2016/09/26/窺探Vue2/</id>
    <published>2016-09-26T06:22:34.000Z</published>
    <updated>2016-09-26T16:12:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="窥探Vue-js2-0"><a href="#窥探Vue-js2-0" class="headerlink" title="窥探Vue.js2.0"></a>窥探Vue.js2.0</h2><p>令人兴奋的Vue.js 2.0马上就要来了。新的VUE有重大的改进，添加了一些新的特性，比如 Virtual-DOM（类似React.js的虚拟DOM），Server Side Rendering（服务端渲染），支持 JSX/Hyperscript 语法等，并去掉了一些已有的方法。</p>
<h2 id="新的特性"><a href="#新的特性" class="headerlink" title="新的特性"></a>新的特性</h2><h3 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h3><p>虚拟DOM 是一个真正DOM的抽象、轻量级版本。<br>它主要作用是让你操控虚拟DOM，来代替直接操控真是DOM。之后虚拟DOM和真是DOM比较，把两者差异的部分再渲染到页面上。<br>这比直接操作DOM的速度要快的多，因为DOM操作是非常耗时的，加入虚拟DOM对比之后减少不必要DOM操作花的时间比进行DOM和虚拟DOM对比的时间要多，所以采用虚拟DOM是更有优势的。更多关于 <a href="https://medium.com/tony-freed-consulting/what-is-virtual-dom-c0ec6d6a925c#.19z4hhwog" target="_blank" rel="external">什么是Virtual Dom？什么是DOM ?</a></p>
<h3 id="Server-Side-Rendering"><a href="#Server-Side-Rendering" class="headerlink" title="Server Side Rendering"></a>Server Side Rendering</h3><p>我们知道 JavaScript 除了可以在浏览器上运行，也可以在服务器端运行，比如 <a href="http://nodejs.org/" target="_blank" rel="external">Node.js</a> 平台。JavaScript在服务端生成HypetText或者HTML文件发送给客户端的浏览器。<br>服务器端渲染（SSR）有几个特点：</p>
<ol>
<li>服务器端渲染可以让搜索引擎更容易读取页面的meta信息以及其他SEO相关信息，大大增加网站在搜索引擎中的可见度。</li>
<li>更快的来生成内容和相对比较慢的来进行数据交互。</li>
<li>首次加载页面的速度加快。客户端渲染的一个缺点是，当用户第一次进入站点，此时浏览器中没有缓存，需要下载代码后在本地渲染，时间较长。而服务器渲染则是，用户在下载的已经是渲染好的页面了，打开速度比本地渲染快。</li>
<li>服务器端多更多的事情，让客户端做尽量少的事，从而可以照顾（不抛弃）那些手机或电脑性能比较特别差又想上网的用户。</li>
</ol>
<p>现在已有的后台服务端框架都可以实现如 <a href="https://www.meteor.com/" target="_blank" rel="external">Meteor</a> ，<a href="http://expressjs.com/" target="_blank" rel="external">Express</a> ，<a href="http://sailsjs.org/" target="_blank" rel="external">Sails</a>。</p>
<h3 id="JSX-（Javascript-XML-syntax-transform）"><a href="#JSX-（Javascript-XML-syntax-transform）" class="headerlink" title="JSX （Javascript XML syntax transform）"></a>JSX （Javascript XML syntax transform）</h3><p>JSX是使用XML语法编写Javascript的一套解析工具，X代表XML。这不是要由引擎或浏览器中实现，它的目的是通过各种预处理程序（transpilers），将这些标记转换成标准的ECMAScript。实质上也就是说JSX是一个语法糖，每一个XML标签都会被JSX转换工具转换成纯Javascript代码。如：</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">   <span class="comment">// Using JSX to express UI components.</span></div><div class="line"><span class="keyword">let</span> dropdown =</div><div class="line">  &lt;Dropdown&gt;</div><div class="line">A dropdown list</div><div class="line">&lt;Menu&gt;</div><div class="line">  &lt;MenuItem&gt;Do Something&lt;/MenuItem&gt;</div><div class="line">  &lt;MenuItem&gt;Do Something Fun!&lt;/MenuItem&gt;</div><div class="line">  &lt;MenuItem&gt;Do Something Else&lt;/MenuItem&gt;</div><div class="line">&lt;/Menu&gt;</div><div class="line">  &lt;/Dropdown&gt;;</div><div class="line">render(dropdown);</div></pre></td></tr></table></figure>
</code></pre><h3 id="Hyperscript"><a href="#Hyperscript" class="headerlink" title="Hyperscript"></a>Hyperscript</h3><p>Hyperscript是JavaScript创建超文本（HTML）的语法。客户端、服务器端都支持。<br>如下代码及其输入：<br>    var h = require(‘hyperscript’)<br>    h(‘h1.fun’, {style: {‘font-family’: ‘Comic Sans MS’}}, ‘Is Guybrush a French name?’)<br><img src="https://github.com/yongbolv/images/blob/master/hyperscript.png?raw=true" alt=""></p>
<h2 id="舍弃和修改的部分"><a href="#舍弃和修改的部分" class="headerlink" title="舍弃和修改的部分"></a>舍弃和修改的部分</h2><p>接下来我将用一个实例演示vue这两个版本间的一些不同的地方。主要包括：</p>
<ul>
<li>events</li>
<li>.sync 依赖的弃用</li>
<li>vm.$set() 方法的弃用</li>
<li>component 组件的模板</li>
<li>一些其他的变化</li>
</ul>
<h3 id="sync-修饰符"><a href="#sync-修饰符" class="headerlink" title=".sync 修饰符"></a>.sync 修饰符</h3><p>当父子组件传参的时候我们肯能会想到把.sync修饰符用于子组件的prop上，以实现数据的双向绑定。从现在起，props 就只有单项绑定了。如果当一个组件需要修改他作用域外的数据的时候，它只能emit一个事件（vm.$emit(event,[..args])事件）让监听器回调，而不是再依赖于之前的隐士绑定了。<br>去掉这个修饰符的目的是为了防止子组件在父组件的范围内所引发的副作用。这样，当你阅读一个组件的代码的时候，就更加容易理解它做了什么以及是如何影响其他部分的。</p>
<h3 id="vue-版本的比较"><a href="#vue-版本的比较" class="headerlink" title="vue 版本的比较"></a>vue 版本的比较</h3><h4 id="用vue-1-0"><a href="#用vue-1-0" class="headerlink" title="用vue 1.0.*"></a>用vue 1.0.*</h4><p>如下脚本所示：<br>这是个用户可以购买宝石的页面，其中有个Vue实例和一个购物车组件。在购物车组件里，用户选择了要购买多少个然后这个购物车组件把这个变化反映给它的父组件。<br>用vue1.0.* 的话，要实现这个功能是显而易见的。我们创建一个变量，来存储所选择的数量，我们把它传递给购物车组件，等待选择数量来更改它的值，在父组件上在写一个computed属性来计算总价格。</p>
<p>\&lt;!DOCTYPE html><br>\<html\><br>\<head\><br>  \<script src="https://cdnjs.cloudflare.com/ajax/libs/vue/1.0.23/vue.js" \="">\</script\><br>  \<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css"\><br>  \<meta charset="utf-8"\><br>  \<title\>Gem Market\</title\><br>\</head\><br>\<body\><br>  \<div class="container"\><br>\<h1\>Gem Market\</h1\><br>\<cart :quantity.sync="quantity"\>\</cart\><br>\<hr\><br>\<div\><br>  \<h3\>You have to pay \<strong\>\</strong\> pieces of gold.\</h3\><br>\</div\><br>  \</div\><br>  \<template id="cart-template"\><br>\<h2\>How many gems would you like to buy?\</h2\><br>\<p\>1 emerald costs 100 pieces of gold.\</p\><br>\<input v-model="quantity" class="form-control" number\><br>  \</template\><br>\</body\><br>\<script type="text/javascript"\><br>Vue.component(‘cart’, {<br>  template: “#cart-template”,<br>  props: { quantity : 0 }<br>});<br>new Vue({<br>  el: ‘.container’,<br>  data : function () {<br>return {<br>  quantity: 0<br>};<br>  },<br>  computed:{<br>gold: function(){<br>  return this.quantity * 100<br>}<br>  }<br>})<br>\</script\><br>\</html\><br><img src="https://github.com/yongbolv/images/blob/master/gemscartvue1.png?raw=true" alt=""></p>
<h4 id="用vue-2"><a href="#用vue-2" class="headerlink" title="用vue 2"></a>用vue 2</h4><p>如果切换到vue 2.0，运行上面的代码，我们会得到以下警告。</p>
<p><em>[Vue warn]: Component template should contain exactly one root element.</em><br>为了去掉这个警告我们在 template内部加上一个Div元素。<br>      <template id="cart-template"><br>    <div><br>      <h2>How many gems would you like to buy?</h2><br>      <p>1 emerald costs 100 pieces of gold.</p><br>      <input v-model="gems" class="form-control" number><br>    </div><br>      </template><br>刷新浏览器，发现这个警告消失。<br>当我们改变这个变量的时候，我们得到这个警告。<br><em>[Vue warn]: Avoid mutating a prop directly since the value will be overwritten whenever the parent component re-renders. Instead, use a data or computed property based on the prop’s value. Prop being mutated: “gems” (found in component: \<cart\>)</em><br>这是因为在vue2中，直接修改prop是被视作反模式的。由于在新的渲染机制中，每当父组件重新渲染时，子组件都会被覆盖，所以应该把props看做是不可变对象 <a href="在面向对象和函数式编程，不可变对象的状态在创建后不能修改">^1</a>。<br>不能更改 quantity prop使其和父组件同步 , 而是让应该这个组件提交个事件给父组件，可以 watch quantity 变量，如果变量发生改变就emit事件，所以这里压根不需要 prop。<br>由于 vm.$dispatch 和 vm.$broadcast 被弃用了，我们用一个集中式事件集线器触发事件 来实现组件间的通讯。建议阅读 <a href="https://github.com/vuejs/vue/issues/2873#upgrade-tips">升级提示</a>。<br>因为在Vue实例中已经实现了事件发射器接口emit，实际开发中可以用空的Vue实例作为事件发射器。<br>让我们看回这个例子，创建一个emitter，重构一下Cart组件。<br>    let bus = new Vue()<br>    Vue.component(‘cart’, {<br>      template: “#cart-template”,<br>      data () {<br>    return {quantity : 0 }<br>      },<br>      watch: {<br>    ‘quantity’: function (quantity, oldQuantity) {<br>      console.log(‘quantity changed from %s to %s’, oldQuantity, quantity)<br>      bus.$emit(‘quantity-changed’, quantity)<br>    }<br>      }<br>    });<br>检查下浏览器控制台，会发现每次改变quantity的值，都会在控制台上打印出变化前后的值。<br><img src="https://github.com/yongbolv/images/blob/master/consoleprint.png?raw=true" alt=""><br>然后，就是要更新父Vue的实例来监听，并更新相应的数据。<br>    new Vue({<br>      el: ‘.container’,<br>      data : function () {<br>          return {<br>             quantity: 0<br>          };<br>      },<br>      created: function () {<br>      // store this to use with Vue.set<br>      var temp = this;<br>      bus.$on(‘quantity-changed’, function (quantity) {<br>          // vm.$set deprecated<br>          Vue.set(temp, ‘quantity’, quantity)<br>      })<br>      },<br>      computed:{<br>          gold: function(){<br>              return this.quantity * 100<br>          }<br>       }<br>    })</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul>
<li>vm.$set() 被弃用了，所以我们用全局方法 Vm.set()。<br>因为不能使用prop去同步，所以我们这样引用购物车组件：<br><code>&lt;cart&gt;&lt;/cart&gt;</code></li>
<li>\’lazy\’ 和 \’number\’ 修饰符更改了，所以我们这样修改下 购物车组件里的Input ：<br>  // Vue 1<br>  <input v-model=”quantity” class=”form-control” number><br>  // Vue 2<br>  <input v-model.number=”quantity” class=”form-control”><br>好了，这就是所有的了，你可以查看最终代码，然后自己把玩一番吧 <a href="https://jsfiddle.net/hootlex/hvv2r8ae/">JSFiddle</a>。<h2 id="其他资源"><a href="#其他资源" class="headerlink" title="其他资源"></a>其他资源</h2>下面列出的资源清单强烈建议你去看下：</li>
<li><a href="https://vuejs.org/2016/04/27/announcing-2.0/"> Vue2官方公告</a><ul>
<li><a href="https://www.youtube.com/watch?v=c9esL3I4IGM">Vue 2 LiveStream</a> 在线看 <a href="https://twitter.com/youyuxi">Evan You</a> 演示的一些新特性和弃用的部分。</li>
</ul>
</li>
<li><a href="https://github.com/vuejs/vue/issues/2873">Vue 2 Features</a>查看所有新功能，弃用和其他的变化。<h2 id="本文引用"><a href="#本文引用" class="headerlink" title="本文引用"></a>本文引用</h2></li>
<li><a href="Why%20is%20React&#39;s%20concept%20of%20Virtual%20DOM%20said%20to%20be%20more%20performant%20than%20dirty%20model%20checking?">Why is React’s concept of Virtual DOM said to be more performant than dirty model checking?</a></li>
<li><a href="https://dotdev.co/peeking-into-vue-js-2-part-1-b457e60c88c6#.yksm6uco2">https://dotdev.co/peeking-into-vue-js-2-part-1-b457e60c88c6#.yksm6uco2</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/02/future-of-dom.html">http://www.ruanyifeng.com/blog/2015/02/future-of-dom.html</a></li>
</ul>
</script></head\></html\></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;窥探Vue-js2-0&quot;&gt;&lt;a href=&quot;#窥探Vue-js2-0&quot; class=&quot;headerlink&quot; title=&quot;窥探Vue.js2.0&quot;&gt;&lt;/a&gt;窥探Vue.js2.0&lt;/h2&gt;&lt;p&gt;令人兴奋的Vue.js 2.0马上就要来了。新的VUE有重大的改进，
    
    </summary>
    
      <category term="技术总结" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue.js技术总结</title>
    <link href="http://yoursite.com/2016/09/26/vue-js%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2016/09/26/vue-js技术总结/</id>
    <published>2016-09-25T16:48:50.000Z</published>
    <updated>2016-09-25T17:30:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vuejs概述"><a href="#vuejs概述" class="headerlink" title="vuejs概述"></a>vuejs概述</h2><p>Vue.js是用于构建交互式的Web界面的库。它提供了MVVM数据绑定和一个可组合的组件系统，具有简单、灵活的API。<br>结合node.js 可以实现前后端开发从物理上的分离。使前端负责View和Controller层，后端负责数据接口，数据存储。<br>感兴趣可以看淘宝ued <a href="http://blog.jobbole.com/65513/" target="_blank" rel="external">《前后端分离的思考与实践》</a></p>
<h3 id="vuejs有以下几个特点"><a href="#vuejs有以下几个特点" class="headerlink" title="vuejs有以下几个特点"></a>vuejs有以下几个特点</h3><h4 id="1-使用简单-如："><a href="#1-使用简单-如：" class="headerlink" title="1.使用简单, 如："></a>1.使用简单, 如：</h4><pre><code>&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;p&gt;{{ note }}&lt;/p&gt;
        &lt;input type=&quot;text&quot; v-model=&quot;note&quot;&gt;
    &lt;/div&gt;
&lt;/body&gt;
var vm = new Vue({
    el: &apos;#app&apos;,
    data: {
        note: &apos;&apos;
    }
})
</code></pre><h4 id="2-外观优雅"><a href="#2-外观优雅" class="headerlink" title="2.外观优雅"></a>2.外观优雅</h4><p><code>&lt;a @click=&quot;doSomething&quot;&gt;&lt;/a&gt;</code><br><code>&lt;a :href=&quot;url&quot;&gt;&lt;/a&gt;</code><br><code>&lt;a @click.stop=&quot;doSomething&quot;&gt;&lt;/a&gt;</code> //阻止单击事件冒泡<br><code>&lt;input @keyup.enter=&quot;submit&quot;&gt;</code> 　　 //只在按下回车键的时候触发事件<br><code>&lt;input v-model=&quot;msg&quot; lazy&gt;</code>　　　　 //lazy: 在’change’而不是’input’事件中更新数据</p>
<h4 id="3-小巧灵活"><a href="#3-小巧灵活" class="headerlink" title="3.小巧灵活"></a>3.小巧灵活</h4><p>gzip压缩后只有25.11kb。<br>松耦合，和路由模块, 网络请求模块，数据模块 等相分离，可单独使用。</p>
<h4 id="4-功能强大"><a href="#4-功能强大" class="headerlink" title="4.功能强大"></a>4.功能强大</h4><ul>
<li>模块化，可以直接使用ES6的模块化功能，再结合Webpack进行相应打包是目前最热门的方案。</li>
<li>组件化， 通过将页面上某一组件的html、CSS、js代码放入一个.vue的文件中进行管理可以大大提高代码的维护性。</li>
<li>路由，结合 vue-router 可以实现各个组件的按需加载，轻松构建单页应用。如：<pre><code>&apos;*&apos;: {component: require(&apos;./components/not-found&apos;)}, //not found handler
&apos;/&apos;: {component: require(&apos;./components/index&apos;)},
&apos;/login&apos;: {component: require(&apos;./components/login&apos;)},
&apos;/field&apos;: {component (resolve) { require([&apos;./components/defconfig/field&apos;], resolve) }},
&apos;/stat&apos;: {component (resolve) { require([&apos;./components/defconfig/stat&apos;], resolve) }}
</code></pre></li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol>
<li>装 node 版本: v6.3.0</li>
<li>装 npm 版本: 3.10.3 </li>
<li>运行命令:  npm install 安装插件 、npm run dev 运行项目 </li>
</ol>
<h2 id="相关工具"><a href="#相关工具" class="headerlink" title="相关工具"></a>相关工具</h2><ol>
<li>FQ工具： <a href="https://www.getlantern.org/" target="_blank" rel="external">lantern</a></li>
<li>Sublime Text3  安装 <a href="https://packagecontrol.io/installation" target="_blank" rel="external">Package Control</a> 安装插件：EditorConfig、Vue Syntax Highlight</li>
<li>chrome插件 安装 <a href="https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd" target="_blank" rel="external">Vue.js devtools</a>(调试vue)  <a href="https://chrome.google.com/webstore/detail/google-translate/aapbdbdomjkkjkaonfhkkikfgjllcleb" target="_blank" rel="external">Google翻译插件</a>  </li>
<li><a href="https://www.telerik.com/download/fiddler" target="_blank" rel="external">抓包工具 fiddler</a></li>
</ol>
<h3 id="vuejs-主要参考库："><a href="#vuejs-主要参考库：" class="headerlink" title="vuejs 主要参考库："></a>vuejs 主要参考库：</h3><ul>
<li><a href="http://cn.vuejs.org/guide/" target="_blank" rel="external">vue</a></li>
<li><a href="http://vuex.vuejs.org/zh-cn/index.html" target="_blank" rel="external">vex</a></li>
<li><a href="http://router.vuejs.org/zh-cn/index.html" target="_blank" rel="external">vue-router</a></li>
<li><a href="https://github.com/vuejs/vue-resource" target="_blank" rel="external">vue-resource</a> </li>
<li><a href="http://yuche.github.io/vue-strap" target="_blank" rel="external">vue-strap</a></li>
</ul>
<h3 id="其他参考库："><a href="#其他参考库：" class="headerlink" title="其他参考库："></a>其他参考库：</h3><ul>
<li><a href="http://v3.bootcss.com" target="_blank" rel="external">bootstrap</a></li>
<li><a href="%20http://eslint.org/">flint</a></li>
<li><a href="%20http://webpack.github.io/docs/">webpack</a></li>
<li><a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">es6</a></li>
<li><a href="http://babeljs.cn/" target="_blank" rel="external">babel</a></li>
<li><a href="https://nodejs.org/en/docs/" target="_blank" rel="external">node.js</a></li>
</ul>
<h3 id="一些开源的插件："><a href="#一些开源的插件：" class="headerlink" title="一些开源的插件："></a>一些开源的插件：</h3><ul>
<li><a href="http://www.zhihu.com/question/38213423" target="_blank" rel="external">http://www.zhihu.com/question/38213423</a></li>
<li><a href="%20https://github.com/vuejs/awesome-vue#libraries--plugins">https://github.com/vuejs/awesome-vue#libraries–plugins</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;vuejs概述&quot;&gt;&lt;a href=&quot;#vuejs概述&quot; class=&quot;headerlink&quot; title=&quot;vuejs概述&quot;&gt;&lt;/a&gt;vuejs概述&lt;/h2&gt;&lt;p&gt;Vue.js是用于构建交互式的Web界面的库。它提供了MVVM数据绑定和一个可组合的组件系统，具有简
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello - World</title>
    <link href="http://yoursite.com/2016/09/25/hello-world/"/>
    <id>http://yoursite.com/2016/09/25/hello-world/</id>
    <published>2016-09-25T11:29:04.000Z</published>
    <updated>2016-09-25T17:12:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><p>``` bash<br>$ hexo new “My New Post”<br>```</p>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><p>``` bash<br>$ hexo server<br>```</p>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><p>``` bash<br>$ hexo generate<br>```</p>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><p>``` bash<br>$ hexo deploy<br>```</p>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
</feed>
