<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Terry&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-10-01T07:20:54.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Terry</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>重排和重绘</title>
    <link href="http://yoursite.com/2016/10/01/%E9%87%8D%E6%8E%92%E5%92%8C%E9%87%8D%E7%BB%98/"/>
    <id>http://yoursite.com/2016/10/01/重排和重绘/</id>
    <published>2016-10-01T07:19:27.000Z</published>
    <updated>2016-10-01T07:20:54.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p>重绘和重排都是发生在浏览器呈现引擎（渲染引擎）中的由于DOM元素改变所作出的事件过程。重绘不一定引起重排，而重排一定引起重绘。<br>重绘：（Repaint） 有的资料也被叫做改型（ Restyling）,是由于元素的外观样式属性的改变所触发的行为，如visibility、背景颜色，边框颜色等属性。<br>重排：（Reflow）也被成为重新布局（Relayout），是由于元素的结构属性（或者说是几何属性）改变所触发的行为，主要场景如下：</p>
<ul>
<li>DOM树节点的操作比， 如：Resizing, Removing, Adding 。</li>
<li>文本的改变，如：text。</li>
<li>浏览器窗口的改变，如： Resizing, Scrolling。</li>
<li>伪类的激活，如：:hover。</li>
<li>Class 属性改变。</li>
<li>Css 属性改变。</li>
<li>新的stylesheets 被添加或者旧的被删除。</li>
</ul>
<h3 id="浏览器对重排的优化："><a href="#浏览器对重排的优化：" class="headerlink" title="浏览器对重排的优化："></a>浏览器对重排的优化：</h3><p>通常浏览器对重绘和重排做了一些优化处理，比如：</p>
<ul>
<li>如果改变一个absolute或者 fixed定位的元素，那么只会重排这个元素和他的子元素，但是当改变了static定位的元素，那么整个页面都会重排。</li>
<li><p>另外比较有趣的是，<br>如下只也会引起一次重绘和一次重排：</p>
<p> var $body = $(‘body’);<br> $body.css(‘padding’, ‘1px’); //no reflow, repaint<br> $body.css(‘color’, ‘red’); //no repaint<br> $body.css(‘margin’, ‘2px’); // reflow, repaint</p>
</li>
</ul>
<p>如上描述，并不是每次属性改变都会引起重排或重绘，有时，它会等一段代码执行结束再一起处理，这样就只发生一次重排。但是如果直接获取属性值，浏览器会强制发生重排来确保获取真实的值。如下：</p>
<pre><code>var $body = $(&apos;body&apos;); 
$body.css(&apos;padding&apos;, &apos;1px&apos;); 
$body.css(&apos;padding&apos;); // forced reflow 
$body.css(&apos;color&apos;, &apos;red&apos;); 
$body.css(&apos;margin&apos;, &apos;2px&apos;);
</code></pre><p>总共我们得到了两此重排，由此看出浏览器的优化失败了。So 如果你想更改一些属性并且想使他们获得如你所愿的性能的时候，可以一起执行修改，然后再获取属性。具体参照下如下的代码： </p>
<pre><code>&lt;!DOCTYPE html\&gt;
&lt;html&gt;
&lt;head&gt;
&lt;script src=&quot;http://code.jquery.com/jquery-2.1.0.min.js&quot;&gt;&lt;/script&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;JS Bin&lt;/title&gt;
&lt;style type=&quot;text/css&quot;&gt;
.block {
  padding: 50px;
  margin: 10px;
  background: #ccc;
}
&lt;/style&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
$(function() {
    var $body = $(&apos;body&apos;);

    // 1 reflow
    $body.on(&apos;click&apos;, &apos;.block-1&apos;, function(e) {
        $body.css(&apos;padding&apos;, &apos;1px&apos;);
        $body.css(&apos;color&apos;, &apos;red&apos;);
        $body.css(&apos;margin&apos;, &apos;2px&apos;);
    })

    // 2 reflows
    .on(&apos;click&apos;, &apos;.block-2&apos;, function(e) {
        $body.css(&apos;padding&apos;, &apos;1px&apos;);
        $body.css(&apos;padding&apos;);
        $body.css(&apos;color&apos;, &apos;red&apos;);
        $body.css(&apos;margin&apos;, &apos;2px&apos;);
    })

    // 3 repaints
    .on(&apos;click&apos;, &apos;.block-3&apos;, function(e) {
        $body.css(&apos;color&apos;, &apos;red&apos;);
        $body.css(&apos;color&apos;);
        $body.css(&apos;color&apos;, &apos;yellow&apos;);
        $body.css(&apos;background&apos;);
        $body.css(&apos;color&apos;, &apos;blue&apos;);
        $body.css(&apos;outline&apos;);
    })

    // 1 repaint
    .on(&apos;click&apos;, &apos;.block-4&apos;, function(e) {
        $body.css(&apos;color&apos;, &apos;red&apos;);
        $body.css(&apos;color&apos;, &apos;yellow&apos;);
        $body.css(&apos;color&apos;, &apos;blue&apos;);

        $body.css(&apos;color&apos;);
        $body.css(&apos;background&apos;);
        $body.css(&apos;outline&apos;);
    })

    // 3 reflows
    .on(&apos;click&apos;, &apos;.block-5&apos;, function(e) {  
        $body.css(&apos;padding&apos;, &apos;1px&apos;);
        $body[0].offsetHeight;
        $body.css(&apos;padding&apos;, &apos;2px&apos;);
        $body[0].offsetTop;
        $body.css(&apos;padding&apos;, &apos;3px&apos;);
        $body[0].offsetWidth;
    })

    // 1 reflow
    .on(&apos;click&apos;, &apos;.block-6&apos;, function(e) {
        $body.css(&apos;padding&apos;, &apos;1px&apos;);
        $body.css(&apos;padding&apos;, &apos;2px&apos;);
        $body.css(&apos;padding&apos;, &apos;3px&apos;);

        $body[0].offsetHeight;
        $body[0].offsetTop;
        $body[0].offsetWidth;
    });
});
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;block block-1&quot;&gt;Click to run example #1 (1 reflow)&lt;/div&gt;
    &lt;div class=&quot;block block-2&quot;&gt;Click to run example #2 (2 reflow)&lt;/div&gt;
    &lt;div class=&quot;block block-3&quot;&gt;Click to run example #3 (3 repaint)&lt;/div&gt;
    &lt;div class=&quot;block block-4&quot;&gt;Click to run example #4 (1 repaint)&lt;/div&gt;
    &lt;div class=&quot;block block-5&quot;&gt;Click to run example #5 (3 reflow)&lt;/div&gt;
    &lt;div class=&quot;block block-6&quot;&gt;Click to run example #6 (1 reflow)&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>有时我们不能避免重排的发生。比如，我们需要设置两次margin-left。第一次设置它100px（没有动画），第二次设置为50px（有动画）。代码如下：</p>
<pre><code>&lt;!DOCTYPE html\&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;&lt;/title&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    $(&apos;.example-1 li&apos;).click(function(){
    $(this).removeClass(&apos;has-transition&apos;);
    $(this).css(&apos;margin-left&apos;, 100);
    $(this).addClass(&apos;has-transition&apos;);
    $(this).css(&apos;margin-left&apos;, 50);
});
$(&apos;.example-2 li&apos;).click(function(){
    $(this).removeClass(&apos;has-transition&apos;);
    $(this).css(&apos;margin-left&apos;, 100);
    $(this)[0].offsetHeight; // 强制执行重排，确保设置的100px能够生效
    $(this).addClass(&apos;has-transition&apos;);
    $(this).css(&apos;margin-left&apos;, 50);
});
&lt;/script&gt;
&lt;style type=&quot;text/css&quot;&gt;
.has-transition {
    -webkit-transition: margin-left 1s ease-out;
    -moz-transition: margin-left 1s ease-out;
    -o-transition: margin-left 1s ease-out;
    transition: margin-left 1s ease-out;
}
li {
    background: #ccc;
    border: 1px #000 solid;
    display: block;
    padding: 2px;
    margin-left: 0;
    margin-top: 4px;
    margin-bottom: 4px;
}
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;第一种情况)&lt;/p&gt;
&lt;ul class=&quot;example-1&quot;&gt;
    &lt;li class=&quot;has-transition&quot;&gt;1&lt;/li&gt;
    &lt;li class=&quot;has-transition&quot;&gt;2&lt;/li&gt;
    &lt;li class=&quot;has-transition&quot;&gt;3&lt;/li&gt;
    &lt;li class=&quot;has-transition&quot;&gt;4&lt;/li&gt;
    &lt;li class=&quot;has-transition&quot;&gt;5&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第二种情况)&lt;/p&gt;
&lt;ul class=&quot;example-2&quot;&gt;
    &lt;li class=&quot;has-transition&quot;&gt;1&lt;/li&gt;
    &lt;li class=&quot;has-transition&quot;&gt;2&lt;/li&gt;
    &lt;li class=&quot;has-transition&quot;&gt;3&lt;/li&gt;
    &lt;li class=&quot;has-transition&quot;&gt;4&lt;/li&gt;
    &lt;li class=&quot;has-transition&quot;&gt;5&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>如上，因为浏览器的缓存的原因只会在脚本的末尾才重排的特性，第一种方案是无法满足需求的，而我们需要有一个重排所以加上一个获取属性的代码<code>$(this)[0].offsetHeight;\</code> 主动调用重排，也就是第二方案就是我们要的效果。</p>
<h3 id="最后是我最近工作中总结的一些关于前端优化的小技巧："><a href="#最后是我最近工作中总结的一些关于前端优化的小技巧：" class="headerlink" title="最后是我最近工作中总结的一些关于前端优化的小技巧："></a>最后是我最近工作中总结的一些关于前端优化的小技巧：</h3><ul>
<li>尽量减少对DOM的操作，如果你对某个属性和对象要进行多次操作，要缓存它们。如果要完成复杂操作的时候，可以多用离线存储技术。</li>
<li>最好只用.class设置元素的样式。</li>
<li>所有的动画都设置为fixed或者absolute定位（要不就不要用动画）。</li>
<li>重排是一个非常昂贵的操作，尽可能多的减少重排的次数和重排的影响范围。</li>
<li>当页面滚动的时候禁用所有的:hover。</li>
<li>在\<head\>标签内引用样式，在\<body\>标签后面引用scripts</body\></head\></li>
<li>尽量让css选择器简单，直观（即使你使用的是预处理程序），越少嵌套越好。选择器的效率排名如下（第一个是最快的）：<ol>
<li>Identificator: #id</li>
<li>Class: .class</li>
<li>Tag: div</li>
<li>Neighbour selector: a + i</li>
<li>Children selector: ul > li</li>
<li>Universal selector: * .  Attribute selector: input<a href="">type=”text”</a></li>
<li>Pseudoelements and pseudoclasses: a:hover<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><a href="http://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#The_rendering_engines_threads" target="_blank" rel="external">浏览器的工作原理：新式网络浏览器幕后揭秘</a><br><a href="http://www.phpied.com/rendering-repaint-reflowrelayout-restyle/" target="_blank" rel="external">Rendering: repaint, reflow/relayout, restyle</a></li>
</ol>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h3&gt;&lt;p&gt;重绘和重排都是发生在浏览器呈现引擎（渲染引擎）中的由于DOM元素改变所作出的事件过程。重绘不一定引起重排，而重排一定引起重绘。&lt;br&gt;重绘：
    
    </summary>
    
      <category term="按下按钮，世界发生了什么" scheme="http://yoursite.com/categories/%E6%8C%89%E4%B8%8B%E6%8C%89%E9%92%AE%EF%BC%8C%E4%B8%96%E7%95%8C%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    
    
      <category term="repaint,reflow,重绘,重排" scheme="http://yoursite.com/tags/repaint-reflow-%E9%87%8D%E7%BB%98-%E9%87%8D%E6%8E%92/"/>
    
  </entry>
  
  <entry>
    <title>weex工作原理</title>
    <link href="http://yoursite.com/2016/09/27/weex%E6%8A%80%E6%9C%AF%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2016/09/27/weex技术工作原理/</id>
    <published>2016-09-27T02:22:34.000Z</published>
    <updated>2016-09-29T16:21:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="weex-工作原理"><a href="#weex-工作原理" class="headerlink" title="weex 工作原理"></a>weex 工作原理</h2><p><em>transformer 会把 template, style, script 都转换成一段段 json 或者 js，这样客户端只接收并运行js，不必同时解析html/css这些语法，并且这些js还会继续进行数据监听和绑定，然后生成最终的virtual dom 再发送给 native端进行渲染。</em><br><img src="https://raw.githubusercontent.com/yongbolv/images/master/weexframework.png" alt=""><br>weex 主要就是做了三件事</p>
<ol>
<li>在服务端用 Transformer 工具把 Vue 代码转换成 Js Bundle。</li>
<li>在客户端运行Js Framework 的 JavaScript 引擎，解释执行Js Bundle生成Virtual DOM。</li>
<li>在客户端设计一套 JS  Bridge，能使IOS端（或者Android端）的Object-C语言（或Java语言）与Javascript语言相互调用，把Virtual Dom转换为DOM，渲染到页面。H5端直接和Js Framework 通讯，不需要Js Bridge。<br>如下为Virtual DOM 渲染为Dom的过程：<br><img src="https://raw.githubusercontent.com/yongbolv/images/master/virtualdom.png" alt=""></li>
</ol>
<h3 id="相关概念："><a href="#相关概念：" class="headerlink" title="相关概念："></a>相关概念：</h3><ul>
<li>ECMAScript：定义了JavaScript语言的标准</li>
<li>JavaScriptCore：应用在在wekit内核内的js引擎，浏览器有Safari。</li>
<li>V8: 应用在chromium内的js引擎，浏览器有Chrome。</li>
<li>JS引擎的作用都是解释和执行JavaScript代码。</li>
<li>有关JavaScript引擎解析的内容请查看 <a href="http://www.uml.org.cn/codeNorms/201306063.asp" target="_blank" rel="external">JavaScriptCore解析</a></li>
<li>有关JavaScriptCore和V8的内容请查看：<a href="http://blog.csdn.net/milado_nju/article/details/22101681" target="_blank" rel="external">JavaScript引擎</a></li>
</ul>
<h3 id="怎么开始搭建个weex项目"><a href="#怎么开始搭建个weex项目" class="headerlink" title="怎么开始搭建个weex项目"></a>怎么开始搭建个weex项目</h3><p>相对比较简单看<a href="https://github.com/alibaba/weex" target="_blank" rel="external">官方</a>吧。  </p>
<h3 id="weex相关工具"><a href="#weex相关工具" class="headerlink" title="weex相关工具"></a>weex相关工具</h3><ul>
<li>node.js</li>
<li>weex-toolkit </li>
<li>Weex Playground App</li>
</ul>
<h3 id="相关论坛"><a href="#相关论坛" class="headerlink" title="相关论坛"></a>相关论坛</h3><ul>
<li><a href="https://github.com/weexteam/article/issues" target="_blank" rel="external">weex 文章</a>  </li>
<li><a href="https://github.com/weexteam/article/issues/50" target="_blank" rel="external">weex 调试</a> </li>
<li><a href="http://alibaba.github.io/weex/doc/" target="_blank" rel="external">weex 文档</a>： </li>
<li><a href="http://www.kmhaoshuai.com/#!/articles/use-vuex-in-weex" target="_blank" rel="external">weex中使用数据流工具Vuex实践</a> </li>
<li><a href="%C2%A0https://gitter.im/weexteam/cn?utm_source=share-link&amp;utm_medium=link&amp;utm_campaign=share-link">weex交流室</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;weex-工作原理&quot;&gt;&lt;a href=&quot;#weex-工作原理&quot; class=&quot;headerlink&quot; title=&quot;weex 工作原理&quot;&gt;&lt;/a&gt;weex 工作原理&lt;/h2&gt;&lt;p&gt;&lt;em&gt;transformer 会把 template, style, script
    
    </summary>
    
      <category term="技术总结" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>渲染篇</title>
    <link href="http://yoursite.com/2016/09/27/%E6%B8%B2%E6%9F%93%E7%AF%87/"/>
    <id>http://yoursite.com/2016/09/27/渲染篇/</id>
    <published>2016-09-27T02:22:34.000Z</published>
    <updated>2016-10-01T06:36:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通常，衡量一个网页最常用的指标，就是看他的 total page load time。显而易见，指出来网页的下载花费了多少时间，这是一个非常重要的性能评估的指标。<br>但是从一个用户角度来说，更重要的标准是从发送请求到网页变为可用需要多少时间，换句话也可以说是需要多长时间能看到页面内容。</p>
<h2 id="浏览器内核的结构分析"><a href="#浏览器内核的结构分析" class="headerlink" title="浏览器内核的结构分析"></a>浏览器内核的结构分析</h2><p>为了更好的优化性能，我们了解一下浏览器内核的基本结构吧，如下是浏览器的主要组件和依赖关系：<br><img src="https://github.com/yongbolv/images/blob/master/broser/data-manage.png?raw=true" alt="浏览器的主要组件" title="浏览器的主要组件"></p>
<h4 id="界面-User-Interface"><a href="#界面-User-Interface" class="headerlink" title="界面 (User Interface)"></a>界面 (User Interface)</h4><p>界面就是包括地址栏、后退/前进按钮、书签目录等，也就是你所看到的除了用来显示你所请求页面的主窗口之外的其他部分。</p>
<h4 id="浏览器引擎-Browser-engine"><a href="#浏览器引擎-Browser-engine" class="headerlink" title="浏览器引擎 (Browser engine)"></a>浏览器引擎 (Browser engine)</h4><p>在用户界面和呈现引擎之间传送指令</p>
<h4 id="呈现引擎-Rendering-engine"><a href="#呈现引擎-Rendering-engine" class="headerlink" title="呈现引擎 (Rendering engine)"></a>呈现引擎 (Rendering engine)</h4><p>用来解析请求来的html和css，并将其显示出来。</p>
<h4 id="网络-Networking"><a href="#网络-Networking" class="headerlink" title="网络 (Networking)"></a>网络 (Networking)</h4><p>用来完成网络的调用。</p>
<h4 id="UI后端-UI-Backbend"><a href="#UI后端-UI-Backbend" class="headerlink" title="UI后端 (UI Backbend)"></a>UI后端 (UI Backbend)</h4><p>来绘制一些基本组件。</p>
<h4 id="JS解释器-JavaScript-Interpreter"><a href="#JS解释器-JavaScript-Interpreter" class="headerlink" title="JS解释器 (JavaScript Interpreter)"></a>JS解释器 (JavaScript Interpreter)</h4><p>Js的解析和执行。</p>
<h4 id="数据存储-Data-Presistence"><a href="#数据存储-Data-Presistence" class="headerlink" title="数据存储 (Data Presistence)"></a>数据存储 (Data Presistence)</h4><p>持久层，也就是需要在硬盘上保存数据。</p>
<h2 id="呈现引擎的概念"><a href="#呈现引擎的概念" class="headerlink" title="呈现引擎的概念"></a>呈现引擎的概念</h2><p>也有翻译成渲染引擎都是指的此，</p>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><ul>
<li>渲染引擎：</li>
<li>解析与DOM树构建</li>
<li>渲染树构建</li>
<li>布局</li>
<li>绘制</li>
<li>动态变化</li>
<li>渲染引擎的线程</li>
<li>CSS2可视模型<br>什么是浏览器的重绘和重排呢?<br>二者何时发生以及如何权衡？<br>将重绘和重排引发的性能问题考虑进去？<h3 id="相关参考："><a href="#相关参考：" class="headerlink" title="相关参考："></a>相关参考：</h3></li>
<li><a href="http://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/" target="_blank" rel="external"> http://www.html5rocks.com/zh/tutorials/internals/howbrowserswork </a></li>
<li><a href="https://medium.com/@luisvieira_gmr/understanding-the-critical-rendering-path-rendering-pages-in-1-second-735c6e45b47a#.95wl113gy" target="_blank" rel="external">https://medium.com/@luisvieira_gmr/understanding-the-critical-rendering-path-rendering-pages-in-1-second-735c6e45b47a#.95wl113gy</a></li>
<li><a href="https://medium.com/@ipestov/all-you-need-to-know-about-web-rendering-c5e27cc77ecb#.7gc9w7ej9" title="重绘和重排" target="_blank" rel="external">All You Need to Know About Web Rendering</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;通常，衡量一个网页最常用的指标，就是看他的 total page load time。显而易见，指出来网页的下载花费了多少时间，这是一个非常
    
    </summary>
    
      <category term="按下按钮，世界发生了什么" scheme="http://yoursite.com/categories/%E6%8C%89%E4%B8%8B%E6%8C%89%E9%92%AE%EF%BC%8C%E4%B8%96%E7%95%8C%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    
    
      <category term="渲染" scheme="http://yoursite.com/tags/%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>窥探Vue.js2.0</title>
    <link href="http://yoursite.com/2016/09/27/%E7%AA%BA%E6%8E%A2Vue2/"/>
    <id>http://yoursite.com/2016/09/27/窺探Vue2/</id>
    <published>2016-09-27T02:22:34.000Z</published>
    <updated>2016-09-29T15:59:35.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="窥探Vue-js2-0"><a href="#窥探Vue-js2-0" class="headerlink" title="窥探Vue.js2.0"></a>窥探Vue.js2.0</h2><p>令人兴奋的Vue.js 2.0马上就要来了。新的VUE有重大的改进，添加了一些新的特性，比如 Virtual-DOM，Server Side Rendering（服务端渲染），支持 JSX/Hyperscript 语法等，并去掉了一些已有的方法。</p>
<h2 id="新的特性"><a href="#新的特性" class="headerlink" title="新的特性"></a>新的特性</h2><h3 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h3><p>在内存中构建一份DOM元素的轻量级版本，当数据更新之后修改Virtual Dom，对修改前后的两棵Virtual DOM 树进行diff差异对比。 把两者差异的部分局部渲染到页面DOM上。而不是直接修改DOM。<br>关于更多 <a href="https://medium.com/tony-freed-consulting/what-is-virtual-dom-c0ec6d6a925c#.19z4hhwog" target="_blank" rel="external">什么是Virtual Dom？什么是DOM ?</a></p>
<h3 id="Server-Side-Rendering"><a href="#Server-Side-Rendering" class="headerlink" title="Server Side Rendering"></a>Server Side Rendering</h3><p>我们知道 JavaScript 除了可以在浏览器上运行，也可以在服务器端运行，比如 <a href="http://nodejs.org/" target="_blank" rel="external">Node.js</a> 平台。JavaScript在服务端生成HypetText或者HTML文件发送给客户端的浏览器。<br>服务器端渲染（SSR）有几个特点：</p>
<ol>
<li>服务器端渲染可以让搜索引擎更容易读取页面的meta信息以及其他SEO相关信息，大大增加网站在搜索引擎中的可见度。</li>
<li>更快的来生成内容和相对比较慢的来进行数据交互。</li>
<li>首次加载页面的速度加快。客户端渲染的一个缺点是，当用户第一次进入站点，此时浏览器中没有缓存，需要下载代码后在本地渲染，时间较长。而服务器渲染则是，用户在下载的已经是渲染好的页面了，打开速度比本地渲染快。</li>
<li>服务器端多更多的事情，让客户端做尽量少的事，从而可以照顾（不抛弃）那些手机或电脑性能比较特别差又想上网的用户。</li>
</ol>
<p>现在已有的后台服务端框架都可以实现如 <a href="https://www.meteor.com/" target="_blank" rel="external">Meteor</a> ，<a href="http://expressjs.com/" target="_blank" rel="external">Express</a> ，<a href="http://sailsjs.org/" target="_blank" rel="external">Sails</a>。</p>
<h3 id="JSX-（Javascript-XML-syntax-transform）"><a href="#JSX-（Javascript-XML-syntax-transform）" class="headerlink" title="JSX （Javascript XML syntax transform）"></a>JSX （Javascript XML syntax transform）</h3><p>JSX是使用XML语法编写Javascript的一套解析工具，X代表XML。这不是要由引擎或浏览器中实现，它的目的是通过各种预处理程序（transpilers），将这些标记转换成标准的ECMAScript。实质上也就是说JSX是一个语法糖，每一个XML标签都会被JSX转换工具转换成纯Javascript代码。如：</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Using JSX to express UI components.</span></div><div class="line"><span class="keyword">let</span> dropdown =</div><div class="line">&lt;Dropdown&gt;</div><div class="line">A dropdown list</div><div class="line">&lt;Menu&gt;</div><div class="line">    &lt;MenuItem&gt;Do Something&lt;/MenuItem&gt;</div><div class="line">    &lt;MenuItem&gt;Do Something Fun!&lt;/MenuItem&gt;</div><div class="line">    &lt;MenuItem&gt;Do Something Else&lt;/MenuItem&gt;</div><div class="line">&lt;/Menu&gt;</div><div class="line">&lt;/Dropdown&gt;;</div><div class="line">render(dropdown);</div></pre></td></tr></table></figure>
</code></pre><h3 id="Hyperscript"><a href="#Hyperscript" class="headerlink" title="Hyperscript"></a>Hyperscript</h3><p>Hyperscript是JavaScript创建超文本（HTML）的语法。客户端、服务器端都支持。<br>如下代码及其输入</p>
<pre><code>var h = require(&apos;hyperscript&apos;)
h(&apos;h1.fun&apos;, {style: {&apos;font-family&apos;: &apos;Comic Sans MS&apos;}}, &apos;Is Guybrush a French name?&apos;)
</code></pre><p><img src="https://github.com/yongbolv/images/blob/master/hyperscript.png?raw=true" alt=""></p>
<h2 id="舍弃和修改的部分"><a href="#舍弃和修改的部分" class="headerlink" title="舍弃和修改的部分"></a>舍弃和修改的部分</h2><p>接下来我将用一个实例演示vue这两个版本间的一些不同的地方。主要包括：</p>
<ul>
<li>events</li>
<li>.sync 依赖的弃用</li>
<li>vm.$set() 方法的弃用</li>
<li>component 组件的模板</li>
<li>一些其他的变化</li>
</ul>
<h3 id="sync-修饰符"><a href="#sync-修饰符" class="headerlink" title=".sync 修饰符"></a>.sync 修饰符</h3><p>当父子组件传参的时候我们肯能会想到把.sync修饰符用于子组件的prop上，以实现数据的双向绑定。从现在起，props 就只有单项绑定了。如果当一个组件需要修改他作用域外的数据的时候，它只能emit一个事件（vm.$emit(event,[..args])事件）让监听器回调，而不是再依赖于之前的隐士绑定了。<br>去掉这个修饰符的目的是为了防止子组件在父组件的范围内所引发的副作用。这样，当你阅读一个组件的代码的时候，就更加容易理解它做了什么以及是如何影响其他部分的。</p>
<h3 id="vue-版本的比较"><a href="#vue-版本的比较" class="headerlink" title="vue 版本的比较"></a>vue 版本的比较</h3><p>为了尽可能阐述清楚这两版本的差异，我用一个实例来解释吧。比如<br>这有个用户可以购买宝石的页面，其中有个Vue实例和一个购物车组件。在购物车组件里，用户选择了要购买多少个然后这个购物车组件把这个变化反映给它的父组件。</p>
<h3 id="用vue-1-0"><a href="#用vue-1-0" class="headerlink" title="用vue 1.0.*"></a>用vue 1.0.*</h3><p>用vue1.0.* 的话，要实现这个功能是显而易见的。我们创建一个变量，来存储所选择的数量，我们把它传递给购物车组件，等待选择数量来更改它的值，在父组件上在写一个computed属性来计算总价格。</p>
<pre><code><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/vue/1.0.23/vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Gem Market<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Gem Market<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">cart</span> <span class="attr">:quantity.sync</span>=<span class="string">"quantity"</span>&gt;</span><span class="tag">&lt;/<span class="name">cart</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>You have to pay <span class="tag">&lt;<span class="name">strong</span>&gt;</span>&#123;&#123; gold &#125;&#125;<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> pieces of gold.<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"cart-template"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>How many gems would you like to buy?<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>1 emerald costs 100 pieces of gold.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"quantity"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">number</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line">Vue.component(<span class="string">'cart'</span>, &#123;</div><div class="line">    <span class="attr">template</span>: <span class="string">"#cart-template"</span>,</div><div class="line">    <span class="attr">props</span>: &#123; <span class="attr">quantity</span> : <span class="number">0</span> &#125;</div><div class="line">&#125;);</div><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">    <span class="attr">el</span>: <span class="string">'.container'</span>,</div><div class="line">    <span class="attr">data</span> : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            <span class="attr">quantity</span>: <span class="number">0</span></div><div class="line">        &#125;;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">computed</span>:&#123;</div><div class="line">        <span class="attr">gold</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.quantity * <span class="number">100</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
</code></pre><p><img src="https://github.com/yongbolv/images/blob/master/gemscartvue1.png?raw=true" alt=""></p>
<h3 id="用vue-2-0"><a href="#用vue-2-0" class="headerlink" title="用vue 2.0"></a>用vue 2.0</h3><p>如果切换到vue 2.0，运行上面的代码，我们会得到以下警告。</p>
<p><em>[Vue warn]: Component template should contain exactly one root element.</em><br>为了去掉这个警告我们在 template内部加上一个Div元素。<br>    <figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"cart-template"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">h2</span>&gt;</span>How many gems would you like to buy?<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">p</span>&gt;</span>1 emerald costs 100 pieces of gold.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"gems"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">number</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>刷新浏览器，发现这个警告消失。<br>当我们改变这个变量的时候，我们得到这个警告。</p>
<p><em>[Vue warn]: Avoid mutating a prop directly since the value will be overwritten whenever the parent component re-renders. Instead, use a data or computed property based on the prop’s value. Prop being mutated: “gems” (found in component: <cart>)</cart></em></p>
<p>这是因为在vue2中，直接修改prop是被视作反模式的。由于在新的渲染机制中，每当父组件重新渲染时，子组件都会被覆盖，所以应该把props看做是不可变对象 <a href="在面向对象和函数式编程，不可变对象的状态在创建后不能修改">^1</a>。<br>不能更改 quantity prop使其和父组件同步 , 而是让应该这个组件提交个事件给父组件，可以 watch quantity 变量，如果变量发生改变就emit事件，所以这里压根不需要 prop。<br>由于 vm.$dispatch 和 vm.$broadcast 被弃用了，我们用一个集中式事件集线器触发事件 来实现组件间的通讯。建议阅读 <a href="https://github.com/vuejs/vue/issues/2873#upgrade-tips" target="_blank" rel="external">升级提示</a>。<br>因为在Vue实例中已经实现了事件发射器接口emit，实际开发中可以用空的Vue实例作为事件发射器。<br>让我们看回这个例子，创建一个emitter，重构一下Cart组件。</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> bus = <span class="keyword">new</span> Vue()</div><div class="line">    Vue.component(<span class="string">'cart'</span>, &#123;</div><div class="line">       <span class="attr">template</span>: <span class="string">"#cart-template"</span>,</div><div class="line">       data () &#123;</div><div class="line">       <span class="keyword">return</span> &#123;<span class="attr">quantity</span> : <span class="number">0</span> &#125;</div><div class="line">       &#125;,</div><div class="line">       <span class="attr">watch</span>: &#123;</div><div class="line">        <span class="string">'quantity'</span>: <span class="function"><span class="keyword">function</span> (<span class="params">quantity, oldQuantity</span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'quantity changed from %s to %s'</span>, oldQuantity, quantity)</div><div class="line">            bus.$emit(<span class="string">'quantity-changed'</span>, quantity)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</code></pre><p>检查下浏览器控制台，会发现每次改变quantity的值，都会在控制台上打印出变化前后的值。<br><img src="https://github.com/yongbolv/images/blob/master/consoleprint.png?raw=true" alt=""><br>然后，就是要更新父Vue的实例来监听，并更新相应的数据。</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">    <span class="attr">el</span>: <span class="string">'.container'</span>,</div><div class="line">    <span class="attr">data</span> : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            <span class="attr">quantity</span>: <span class="number">0</span></div><div class="line">        &#125;;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">created</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">// store this to use with Vue.set</span></div><div class="line">        <span class="keyword">var</span> temp = <span class="keyword">this</span>;</div><div class="line">        bus.$on(<span class="string">'quantity-changed'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">quantity</span>) </span>&#123;</div><div class="line">            <span class="comment">// vm.$set deprecated</span></div><div class="line">            Vue.set(temp, <span class="string">'quantity'</span>, quantity)</div><div class="line">        &#125;)</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">computed</span>:&#123;</div><div class="line">        <span class="attr">gold</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.quantity * <span class="number">100</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</code></pre><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul>
<li>vm.$set() 被弃用了，所以我们用全局方法 Vm.set()。<br>因为不能使用prop去同步，所以我们这样引用购物车组件：</li>
</ul>
<p><code>&lt;cart&gt;&lt;/cart&gt;</code></p>
<ul>
<li><p>\’lazy\’ 和 \’number\’ 修饰符更改了，所以我们这样修改下 购物车组件里的Input</p>
<p>  ```HTML<br>  // Vue 1<br>  <input v-model="”quantity”" class="”form-control”" number=""><br>  // Vue 2<br>  \<input v-model.number="”quantity”" class="”form-control”\"><br>  ```</p>
</li>
</ul>
<p>好了，这就是所有的了，你可以查看最终代码，然后自己把玩一番吧 <a href="https://jsfiddle.net/hootlex/hvv2r8ae/" target="_blank" rel="external">JSFiddle</a>。</p>
<h2 id="其他资源"><a href="#其他资源" class="headerlink" title="其他资源"></a>其他资源</h2><p>下面列出的资源清单强烈建议你去看下：</p>
<ul>
<li><a href="https://vuejs.org/2016/04/27/announcing-2.0/" target="_blank" rel="external"> Vue2官方公告</a></li>
<li><a href="https://www.youtube.com/watch?v=c9esL3I4IGM" target="_blank" rel="external">Vue 2 LiveStream</a> 在线看 <a href="https://twitter.com/youyuxi" target="_blank" rel="external">Evan You</a> 演示的一些新特性和弃用的部分。</li>
<li><a href="https://github.com/vuejs/vue/issues/2873" target="_blank" rel="external">Vue 2 Features</a>查看所有新功能，弃用和其他的变化。</li>
</ul>
<h2 id="本文引用"><a href="#本文引用" class="headerlink" title="本文引用"></a>本文引用</h2><ul>
<li><a href="Why%20is%20React&#39;s%20concept%20of%20Virtual%20DOM%20said%20to%20be%20more%20performant%20than%20dirty%20model%20checking?">Why is React’s concept of Virtual DOM said to be more performant than dirty model checking?</a></li>
<li><a href="https://dotdev.co/peeking-into-vue-js-2-part-1-b457e60c88c6#.yksm6uco2" target="_blank" rel="external">https://dotdev.co/peeking-into-vue-js-2-part-1-b457e60c88c6#.yksm6uco2</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/02/future-of-dom.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2015/02/future-of-dom.html</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;窥探Vue-js2-0&quot;&gt;&lt;a href=&quot;#窥探Vue-js2-0&quot; class=&quot;headerlink&quot; title=&quot;窥探Vue.js2.0&quot;&gt;&lt;/a&gt;窥探Vue.js2.0&lt;/h2&gt;&lt;p&gt;令人兴奋的Vue.js 2.0马上就要来了。新的VUE有重大的改进，
    
    </summary>
    
      <category term="技术总结" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue.js技术总结</title>
    <link href="http://yoursite.com/2016/09/26/vue-js%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2016/09/26/vue-js技术总结/</id>
    <published>2016-09-25T16:48:50.000Z</published>
    <updated>2016-09-29T02:46:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vuejs概述"><a href="#vuejs概述" class="headerlink" title="vuejs概述"></a>vuejs概述</h2><p>Vue.js是用于构建交互式的Web界面的库。它提供了MVVM数据绑定和一个可组合的组件系统，具有简单、灵活的API。<br>结合node.js 可以实现前后端开发从物理上的分离。使前端负责View和Controller层，后端负责数据接口，数据存储。<br>感兴趣可以看淘宝ued <a href="http://blog.jobbole.com/65513/" target="_blank" rel="external">《前后端分离的思考与实践》</a></p>
<h3 id="vuejs有以下几个特点"><a href="#vuejs有以下几个特点" class="headerlink" title="vuejs有以下几个特点"></a>vuejs有以下几个特点</h3><h4 id="1-使用简单-如："><a href="#1-使用简单-如：" class="headerlink" title="1.使用简单, 如："></a>1.使用简单, 如：</h4><pre><code>&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;p&gt;{{ note }}&lt;/p&gt;
        &lt;input type=&quot;text&quot; v-model=&quot;note&quot;&gt;
    &lt;/div&gt;
&lt;/body&gt;
var vm = new Vue({
    el: &apos;#app&apos;,
    data: {
        note: &apos;&apos;
    }
})
</code></pre><h4 id="2-外观优雅"><a href="#2-外观优雅" class="headerlink" title="2.外观优雅"></a>2.外观优雅</h4><p><code>&lt;a @click=&quot;doSomething&quot;&gt;&lt;/a&gt;</code><br><code>&lt;a :href=&quot;url&quot;&gt;&lt;/a&gt;</code><br><code>&lt;a @click.stop=&quot;doSomething&quot;&gt;&lt;/a&gt;</code> //阻止单击事件冒泡<br><code>&lt;input @keyup.enter=&quot;submit&quot;&gt;</code> 　　 //只在按下回车键的时候触发事件<br><code>&lt;input v-model=&quot;msg&quot; lazy&gt;</code>　　　　 //lazy: 在’change’而不是’input’事件中更新数据</p>
<h4 id="3-小巧灵活"><a href="#3-小巧灵活" class="headerlink" title="3.小巧灵活"></a>3.小巧灵活</h4><p>gzip压缩后只有25.11kb。<br>松耦合，和路由模块, 网络请求模块，数据模块 等相分离，可单独使用。</p>
<h4 id="4-功能强大"><a href="#4-功能强大" class="headerlink" title="4.功能强大"></a>4.功能强大</h4><ul>
<li>模块化，可以直接使用ES6的模块化功能，再结合Webpack进行相应打包是目前最热门的方案。</li>
<li>组件化， 通过将页面上某一组件的html、CSS、js代码放入一个.vue的文件中进行管理可以大大提高代码的维护性。</li>
<li>路由，结合 vue-router 可以实现各个组件的按需加载，轻松构建单页应用。如：<pre><code>&apos;*&apos;: {component: require(&apos;./components/not-found&apos;)}, //not found handler
&apos;/&apos;: {component: require(&apos;./components/index&apos;)},
&apos;/login&apos;: {component: require(&apos;./components/login&apos;)},
&apos;/field&apos;: {component (resolve) { require([&apos;./components/defconfig/field&apos;], resolve) }},
&apos;/stat&apos;: {component (resolve) { require([&apos;./components/defconfig/stat&apos;], resolve) }}
</code></pre></li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol>
<li>装 node 版本: v6.3.0</li>
<li>装 npm 版本: 3.10.3 </li>
<li>运行命令:  npm install 安装插件 、npm run dev 运行项目 </li>
</ol>
<h2 id="相关工具"><a href="#相关工具" class="headerlink" title="相关工具"></a>相关工具</h2><ol>
<li>FQ工具： <a href="https://www.getlantern.org/" target="_blank" rel="external">lantern</a></li>
<li>Sublime Text3  安装 <a href="https://packagecontrol.io/installation" target="_blank" rel="external">Package Control</a> 安装插件：EditorConfig、Vue Syntax Highlight</li>
<li>chrome插件 安装 <a href="https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd" target="_blank" rel="external">Vue.js devtools</a>(调试vue)  <a href="https://chrome.google.com/webstore/detail/google-translate/aapbdbdomjkkjkaonfhkkikfgjllcleb" target="_blank" rel="external">Google翻译插件</a>  </li>
<li><a href="https://www.telerik.com/download/fiddler" target="_blank" rel="external">抓包工具 fiddler</a></li>
<li><a href="https://github.com/vuejs/vue-cli" target="_blank" rel="external">vue-cli</a> vue的脚手架 </li>
</ol>
<h3 id="vuejs-主要参考库："><a href="#vuejs-主要参考库：" class="headerlink" title="vuejs 主要参考库："></a>vuejs 主要参考库：</h3><ul>
<li><a href="http://cn.vuejs.org/guide/" target="_blank" rel="external">vue</a></li>
<li><a href="http://vuex.vuejs.org/zh-cn/index.html" target="_blank" rel="external">vex</a></li>
<li><a href="http://router.vuejs.org/zh-cn/index.html" target="_blank" rel="external">vue-router</a></li>
<li><a href="https://github.com/vuejs/vue-resource" target="_blank" rel="external">vue-resource</a> </li>
<li><a href="http://yuche.github.io/vue-strap" target="_blank" rel="external">vue-strap</a></li>
</ul>
<h3 id="其他参考库："><a href="#其他参考库：" class="headerlink" title="其他参考库："></a>其他参考库：</h3><ul>
<li><a href="http://v3.bootcss.com" target="_blank" rel="external">bootstrap</a></li>
<li><a href="%20http://eslint.org/">flint</a></li>
<li><a href="%20http://webpack.github.io/docs/">webpack</a></li>
<li><a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">es6</a></li>
<li><a href="http://babeljs.cn/" target="_blank" rel="external">babel</a></li>
<li><a href="https://nodejs.org/en/docs/" target="_blank" rel="external">node.js</a></li>
</ul>
<h3 id="一些开源的插件："><a href="#一些开源的插件：" class="headerlink" title="一些开源的插件："></a>一些开源的插件：</h3><ul>
<li><a href="http://www.zhihu.com/question/38213423" target="_blank" rel="external">http://www.zhihu.com/question/38213423</a></li>
<li><a href="%20https://github.com/vuejs/awesome-vue#libraries--plugins">https://github.com/vuejs/awesome-vue#libraries–plugins</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;vuejs概述&quot;&gt;&lt;a href=&quot;#vuejs概述&quot; class=&quot;headerlink&quot; title=&quot;vuejs概述&quot;&gt;&lt;/a&gt;vuejs概述&lt;/h2&gt;&lt;p&gt;Vue.js是用于构建交互式的Web界面的库。它提供了MVVM数据绑定和一个可组合的组件系统，具有简
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello - World</title>
    <link href="http://yoursite.com/2016/09/25/hello-world/"/>
    <id>http://yoursite.com/2016/09/25/hello-world/</id>
    <published>2016-09-25T11:29:04.000Z</published>
    <updated>2016-09-27T06:36:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><p><code>bash</code>$ hexo new “My New Post”<br><code>``
</code><br>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><p><code>`` bash</code>$ hexo server<br><code>
</code><br>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><p>``` bash<br>$ hexo generate<br>```</p>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><p>``` bash<br>$ hexo deploy<br>```</p>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
</feed>
